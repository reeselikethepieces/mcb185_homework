##python info
		""
		made of
		multi-line
		comments 
		using double quotes
		""
	Maths
		cant do maths 
			'1' = text with numeral "1" 
		can do maths
			scientific notation
				1.5e-2 
			integers (ints)
				1 = integer
					// = division operation (throws away remainder)
						% = modulo operation (calls the remainder) 
					** = exponents
					() = precedence - think P in PEMDAS 
			floating point numbers (floats) - approx. w/ finite precision 
				1.0 = floating point number (has decimal) 
				0.1 isn't exactly = to 0.1 
					(ex) (0.1 * 1) = 0.1 but... 
						 (0.3 * 1) = 0.30000000000000004 <-- whaaaat? 
						why tho? 
							b/c 0.1 cannot be rep. exactly by IEEE754 standard for storing 8-byte floats 
								above, python printed (0.1 * 1)  = 0.1 
								however, python is being a snake:
									it really is 0.100000001490116119384765625
		(operations) 
			+, -, *, /, **, //, %, ()
		(functions) 
			abs(x) = absolute value of x 
			pow(x, y) = x to the power y 
			round(x, ndigits=3) = round off x to 3 digits 	
		(special functions = import statements)
			math.ceil(x) = round x up
			math.floor(x) = round x down
			math.log(x) = x in log base e
			math.log2(x) = " "  "   "   2
			math.log10(x) = " " "   "  10
			math.sqrt(x) = square root of x
			math.pow(x, y) 
			math.factorial(n) = factorial integer n 
		(constants)
			math.e		2.71828... 
			math.pi		3.14159...
			math.inf	infinity
			math.nan	not anumber (e.g. 0/0)
		(math no-nos) 
			(1/0)	      	   # divide by zero error
			(math.log(0))      # math domain error
			(math.sqrt(-1))    # math domain error
			((-1)**0.5)        # complex number, not a math domain error 
	Variables
		assignment 
			(ex 1) a = 3                       # side
				   b = 4                       # side  
				   c = math.sqrt(a**2 + b**2)  # hypotenuse 
				   print(c)
				#note that a and b are both ints b/c their numerical values don't have decimals 
				#further, the pythagorean thm- math.sqrt("") creates floats 
					--> ergo, variable c is a float 
		type
			all created variables have a type; to see this, use function [type()] 
			 --> first time using print() with multiple arguments 
					print(type(a), type(b), type(c))
						in terminal, it will look like this: <class 'int'> <class 'int'> <class 'float'>
					print(type (a), type (b), type(c), sep=', ')
						in terminal, it will look like this: <class 'int'>, <class 'int'>, <class 'float'>
							--> thus, by using the SEPARATOR from a " "(space) to a "," comma 
	Functions --> reusable code constructs 
			  --> form backbone of programs 
			- has arguments 
			- similar to commands but have stricter rules 
		def --> creates a function 
			~~~~ formula ~~~~ def uniquefunction (): 
								  a_second_uniquefunction ()
				#general note: dont use statement, print() in a function			
		block structure --> fxns and other stxtrs use this (later in course) 
						--> shows heirarchy 
			(ex) say we want to do pythagorean thm with: a = 3, b = 4, and c = math.sqrt(a**2 + b**2)
					and we want to re-use over/over --> x = pythagoras(3, 4), it would look like: 
						def pythagoras(a, b):
							c = math.sqrt(a**2 + b**2)
							return c
					we would run it like this: 
						x = pythagoras(3, 4)
						print (x)
					tbh, we dont need to type the variables c or x:
						def pythagoras (a, b):
							return math.sqrt(a**2 + b**2)
						
						print (pythagoras(3, 4))
						print (pythagoras(1, 1))
			(practice 1) - see practice_functions.txt 
	Strings
	Conditionals
		if
		boolean
		chaining
		floating point warning
		string comparison
		mismatched type error
			(practice 2) 
	#Style
		spacing
		naming
			
		
			
			
		
### vocab terms ### 
	CLI	- command line interface
			- flavors: options of CLI  
				- commands (name of program)
					-three parts 
						- the command 
							-subcommand (optional & comes after)
						-options - 
						-arguments - follows a command or option with more words	
							- some arguments are sub-commands 
							- some are mandatory; some are not 
							- some have parameters; some don't 
				- whitespace (blank lines)
					- two flavors:(1)horizontal
					
						(2)vertical 
						
				- flags 
				- parameters
				- statement
					i.e. print () function (programs consist of many stmts + other stuff-later)
				- comment - like a note 
					"#" pound/hash 
						@ beginning = comment 
						@ end of a line = rest of the line is a comment 
						using comments can explain the _intent_ of variables 
	streams of Data 
		- 	stdout - standard output - the output sent to the terminal by commands 
				> 	- operator re-directs stdout of a program to a file 
		-	stdin - standard input - another way to send/view a stream of data(bytes)
				wc 	  - worng program, capable of reading stdin and file 
				|	  - pipe operator - connects stdout of one program to stdin in of another
						(no files between them, just streams) 
				< 	  - operator re-directs contents of a file to stdin of a program (keyboard is the source???)
		-	stderr - standard error - error messages rather than data 
	/dont know where to put but important  
	Token - 
		- .. parent directory (directory above current directory) 
	Program
	Directories
		/ root
		
##key concepts##
stream 			vs 			file 
unknown legnth				set size
		 	
###symbols###
"^aa" - the "^" indiciates at the beginning 
"aa$" - the "$" indicates at the end 
"z.z" - the "." matches any single letter (z one letter apart) 		
		- can build off of this by adding "*" after the . (z.*z)
			- this ex looks for words that have a have any number (*) between the two z's 
		- can do "z.\+z" to represent one or more 
			alternateively, -E "z.+z" - the 
					[- E] flag (extended syntax) used later on 
		- can do -E "z.{3,4}z" - this will allow you to find words where there are 3-4 letters b/w z's
			alternateively, leave off the upper bound (4) but keep the comma for unlimited 3 or more 
[character class] 
		- ex:  grep -E "z[aeiou]+z" searches for specific classes of letters 
			this ex shows the middle letters to be one or more of the vowels 
		alternateively, you can do the opposite of this (anti) simply be adding a "^" in front of the vowels

### commands - what they do/mean ###
	basic commands
		cd		- change directory
		mkdir 	- make new directory 
		rmdir 	- removes new directory* only works when there are no files in it
		pwd		- print working directory (show current envmt location)
		rm		- delete
		rm *	- trash 
			- git restore - ctrlz
		date	- obvi
			[- u] flag (on/off; raised/not)
			[- d] parameter 
		sort	- ""
			[- u] flag that restricts to unique text only
			[- n] numeric order 
			[- r] reverse order 
		ls		- list
			[ls -l]	- shows longer listing of file attributes, including a 0 for the size of bar
				[ls-;h] - humanizes 
		ln 		- use of relative path 
			[-s] ????
		commit	- to change 
			[- m]les
		sh 		- run the program 
		gunzip 
			[-c] - a "flag" 
				- commonly used for wc on compressed files (can use this instead of wc) 
		cut		- splits fields on tab characters 
			to use, three columns are needed: cut -f 3 (this ex shows -f3 wants to cut at column 3)
		grep	- powerful program that SEARCHES for specific patterns of text 
			[- v]
				- remove comments - in the ex, "^#" was used - the carrot ^ stands for beginning/start
		uniq 	- removes duplicates 
			[-c ] 
				- counters occurrences of each line 
	/creating and modifying files
			less	- view text files
			touch 	- creates an _empty_ file 
				 alternateively, [>] can be used by re-directing stdout 
			nano	- edits to a text file that is a terminal-based text editor 
					- can also create new files 
	/moving, renaming, copying, compression
		mv		- rename and move files 
					to rename, simply key in [mv] [previous name] [desired new name].txt
					to move, simply key in [mv] [name].txt [File/]
		cp		- copies a file . <-- this period represents the current location you are in 
		diff 	- see difference between two files 
					good for small txt files
		sum		- performs checksum, a pseudo-unique # whos value is based on the entire file contents
					good for validating two compressed genome seq files having the same seq
					checksums (how passowrds work- dont run through the internet, but the checksum checks)columns
						checksum value | ??? # of that text doc | file.name 
					flavors of checksums 
						MD5 - zee commies - what the internet runs on 
		gzip	- compress file - large files - default behavior is to create new and destroy old 
			- zless - less command but for compressed files 
		
	/viewing files
		cat 	- dump contents
		print() - function called statement 
		head	- print first 10 lines of file 
		tail	- print last 10 lines of file 
		more	- page to page
		less	- page to page with more control
		zless	- "" but with compressed files
	/absolute and relative paths 
		[/] and [~/] - paths beginning with / or ~/ = absolute paths, otherwise they are relative
		[.] and [..] tokens = relative paths to current and parent directories 
			- enviornment variables can be either a or r 
	/file endings
		.txt 
		.pdf
		.gz 	compressed with gzip 
				 - tab-delimited text files containing info about seqs.
				 - cut, sort, and uniq 
					
		.py 	python
	
	
## subcommands ##
	git add
	git status
	git push (to)
	git pull (from, if changes) 
	git restore (back to OG)
 

## shortcuts ##
	~/path 	the tilde expands to the location of your home directory
	up arrow
	CtrlC aka ^C breaks out		ex: typing "yes" in terminal 
			  ^A start of CLI
			  ^E end of CLI 
			  "q" to quit out of program 
	#tab completion#
		his
	* Wildcard = matches missing characters if it can
	#aliases#
	
	
###Other###
	##soft link##
	- aka symbolic links or short cuts (friendly way of looking at really long file names) 
	
	
	
### editor ### 
	echo "text"		- this text will _echo_ in the terminal when you call it
	
	
	relative to a path = i.e. Code/MCB185 and relative path to directory 
	and Code/MCB185/README.md = absolute path 


a 1
b 2
c 3
z 0
ab 3
ac 4
abc 6
az 1
zz 00
hello 
8 + 5 + 12 + 12 + 14 = 51/26 = 

a = 3
b = 4
 